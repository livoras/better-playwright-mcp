# 智能采样算法设计文档

## 核心理念

通过**递归的列表检测和折叠**，将重复结构压缩为样本+计数形式，保留最大语义信息。

## 三层压缩策略

### 1. 文本级压缩
对于超长内容，只保留有意义的前缀：

```
原始: "INFINITIPRO Tourmaline 1 1/2-Inch Ceramic Curling Iron, 1 ½ inch barrel produces soft waves – for use on medium and long hair"
压缩: "INFINITIPRO Tourmaline 1 1/2-Inch Ceramic..."
```

### 2. 列表级压缩
识别重复模式，展示第一个完整样本，折叠其余：

```
实际DOM结构（基于accessibility tree）：
- list
  - listitem "热门商品"        // 这是标题，独立显示
  - listitem [ref=e1234]       // 第一个真正的商品，完整展示
    - link: "卷发棒产品1"
    - text: "$29.99"
    - button: "Add to cart"
  - listitem (... 还有49个相似商品) [refs=e1235,e1236,...]
```

### 3. 递归压缩
第一个样本内部的列表也同样处理：

```
- listitem [ref=e1234]
  - heading: "卷发棒产品1"
  - generic                    // 图片容器
    - img
    - img (... 还有4张图片)
  - generic                    // 评论容器
    - text: "很好用..." 
    - text (... 还有99条评论)
```

## 列表模式识别

### 判定标准
1. **结构相似性** - DOM子树结构相似（不仅仅是标签名）
2. **位置相邻性** - 在DOM树中是兄弟节点
3. **数量阈值** - 至少3个相似元素才识别为列表
4. **灵活边界** - 列表不必从第一个元素开始，找最大相似子序列

### 相似度计算
- 使用SimHash或树编辑距离
- 考虑子树的：
  - 节点类型分布
  - 树形结构
  - 深度和宽度特征
- 基于实际DOM元素（listitem、button、link等），不硬编码假设

## 实现优势

1. **信息密度最大化**
   - 通过折叠表达原本需要多行的重复结构
   - AI能理解"这里有50个商品"而不是看到50个重复结构

2. **语义清晰**
   - "商品列表(50个)" vs "generic元素(497个)"
   - 保留了业务含义

3. **操作精确**
   - 通过ref系统，AI仍能定位任何具体元素
   - 第一个样本提供了完整的操作模板

## 算法流程

```
输入: DOM快照
↓
1. 遍历DOM树，识别列表模式
   a. 优先识别语义列表（连续的listitem）
   b. 通过SimHash识别结构相似的元素组
   c. 找最大相似子序列（不要求从第一个开始）
↓
2. 对每个列表：
   - 保留第一个相似元素的完整结构（可能是第2个）
   - 折叠其余为计数 + refs
   - 特殊元素（如标题）独立保留
↓
3. 对保留的元素递归应用步骤2
↓
4. 对所有文本内容应用长度限制
↓
输出: 智能折叠后的结果
```

## 预期效果

原始（5546行）:
```
- 497个generic元素展开
- 大量重复的商品卡片结构
- 冗余的完整文本
```

压缩后:
```
- 页面骨架（导航、搜索框）
- 商品列表：1个完整样本 + "还有49个"
- 筛选器：1个完整样本 + "还有15个"  
- 所有长文本截断到合理长度
```

## 关键挑战

1. **列表边界识别** - 如何准确判断列表的开始和结束
   - 列表可能有标题（第一个元素是说明）
   - 列表可能有尾部（最后有"查看更多"按钮）
   - 需要找最大连续相似子序列

2. **嵌套列表处理** - 避免递归压缩导致信息丢失过多
   - 每层独立判断和压缩
   - 保持结构层次的可读性

3. **异构列表** - 处理"大部分相似但有个别不同"的情况
   - 容忍少量异常项
   - 使用SimHash的汉明距离阈值

4. **性能优化** - 5000行的相似度计算需要高效算法
   - 缓存已计算的SimHash值
   - 限制递归深度
   - 只对兄弟节点进行相似度比较